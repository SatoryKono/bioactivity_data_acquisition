> **Note**: Implementation status: **planned**. All file paths referencing
> `src/bioetl/` in this document describe the intended architecture and are not
> yet implemented in the codebase.

Промт: «Типобезопасные конфиги и слои включений» Роль и режим работы

Ты — системный аналитик ETL и разработчик. Работаешь строго по содержимому ветки
test_refactoring_32 репозитория SatoryKono/bioactivity_data_acquisition. Никаких
внешних предположений. Источник истины — только файлы репозитория. Все ссылки
внутри результата оформляй так:

\[ref: repo:<path>@refactoring_001\]

Обязательные источники

[ref: repo:README.md@refactoring_001] — в «Быстрый старт» зафиксированы запуск
через CLI, применение PipelineConfig, а также автоподмешивание base.yaml и
determinism.yaml. Используй это как рамку поведения. GitHub

[ref: repo:docs/configs/00-typed-configs-and-profiles.md@refactoring_001] —
точка входа раздела конфигураций, нужно связать с новым артефактом. GitHub

[ref: repo:src/bioetl/cli/cli_app.py@refactoring_001] — фактическая логика
загрузки конфигов и профилей в CLI, порядок приоритета. GitHub

[ref: repo:src/bioetl/configs/models.py@refactoring_001] — типы и поля
PipelineConfig и смежных моделей. Снимай структурами и не додумывай полей,
которых нет. GitHub

Задача

Подготовь самодостаточную спецификацию «Типобезопасные конфиги и слои
включений», которая:

формально описывает структуру и типы конфигураций пайплайнов (PipelineConfig и
связанные модели);

фиксирует правила валидации и отчёт об ошибках;

задаёт алгоритм мерджа слоёв (base.yaml, профиль determinism.yaml, иные профили,
флаги CLI — строго по коду);

даёт минимальные скелеты YAML и пример корректного конфига;

описывает интеграцию с CLI и влияния профилей на детерминизм выгрузок. Опирайся
на README, где прямо сказано про применение PipelineConfig, base.yaml и
determinism.yaml при запуске команд Typer. GitHub

Что нужно выдать (два файла)

docs/configs/00-typed-configs-and-profiles.md — спецификация.

configs/defaults/base.yaml и configs/defaults/determinism.yaml — минимальные,
рабочие скелеты с комментариями. Положи рядом с уже существующими конфигами
проекта и свяжи из docs/configs/00-typed-configs-and-profiles.md. GitHub

Обязательное содержание спецификации (структура разделов)

1. Обзор и цели

Коротко определяешь роль типобезопасных конфигов и профильного каскада. Сошлись
на том, что CLI при запуске пайплайна автоматически применяет структуру
PipelineConfig и значения из base.yaml и determinism.yaml (см. README, блок
Quick Start). GitHub

1. Структура и типы PipelineConfig

Извлеки из кода точные поля, типы, значения по умолчанию и вложенные структуры
(строго из [ref: repo:src/bioetl/configs/models.py@refactoring_001]).

Для каждого поля зафиксируй: тип, required/optional, default, допустимый
диапазон/формат, комментарий.

Составь таблицу «ключ → тип → required → default → описание» для всего дерева
конфигурации. GitHub

1. Валидация и отчёт об ошибках

Опиши, какие проверки исполняются на уровне типов и инвариантов (например:
существование путей, непустые ключи, пересекающиеся параметры).

Определи формат сообщения об ошибке валидации: включай путь до поля (a.b.c),
ожидаемый тип и фактическое значение.

Запрети «тихие» незадекларированные ключи: неизвестный ключ должен приводить к
ошибке.

Приведи 2–3 примера невалидных YAML и ожидаемых сообщений валидации.

1. Слои и алгоритм мерджа

Формально опиши порядок применения слоёв, ориентируясь на фактическую логику из
CLI:

базовый слой base.yaml;

профиль(и), включая determinism.yaml;

явный файл --config команды;

флаги CLI, если они переопределяют ключи конфига.

Укажи стратегию мерджа: «глубокий» по словарям, правила для списков (замена или
конкатенация), как обрабатываются null и пустые значения.

Добавь псевдокод мерджа, синхронизированный с реализацией в \[ref:
repo:src/bioetl/cli/cli_app.py@refactoring_001\]. GitHub

1. Профиль determinism.yaml

Опиши, какие ключи в нём задают поведение детерминизма выгрузок: сериализация,
сортировка, таймзона/локаль, флаги атомарной записи, включение meta.yaml и т. п.

Покажи минимальный рабочий скелет профиля и укажи, какие поля он должен
переопределять в PipelineConfig.

Сошлись на заявлении README о том, что determinism.yaml применяется при запуске
CLI. GitHub

1. Примеры YAML

base.yaml — значения по умолчанию для логирования, сериализации, путей вывода и
т. п.

determinism.yaml — явные настройки, фиксирующие байтовую воспроизводимость.

Полный пример итогового config.yaml конкретного пайплайна (например, activity) с
пометками, какие ключи пришли из каждого слоя.

1. Интеграция с Typer-CLI

Опиши, как CLI подхватывает PipelineConfig и включает слои при запуске команд
python -m bioetl.cli.cli_app <pipeline>.

Включи командные примеры из README и расширь их вариантами с --profile
determinism и --dry-run, пояснив влияние профиля на результат. GitHub

1. Тест-план конфигов

Юнит-тесты: валидация обязательных полей, неизвестные ключи, неверные типы,
мердж списков/словарей.

Интеграционные тесты CLI: проверка порядка приоритета слоёв и того, что флаги
переопределяют YAML.

Golden-тест: стабильно одинаковый «эффективный конфиг» при одних и тех же входах
и профилях.

Требования к оформлению

Язык: русский.

Файл 00-typed-configs-and-profiles.md строится как нормативка: таблицы ключей,
псевдокод мерджа, блоки YAML.

Все ссылки — только в формате \[ref: repo:<path>@refactoring_001\].

Никаких полей «из головы»: всё, чего нет в коде, помечай как «опционально к
введению» только в разделе «Рекомендации» и отдельно от «Текущей спецификации».

Критерии приёмки (MUST)

Таблицы ключей полностью соответствуют PipelineConfig и его моделям в \[ref:
repo:src/bioetl/configs/models.py@refactoring_001\]; отсутствуют
незадекларированные поля. GitHub

Описанный порядок приоритета слоёв совпадает с фактической логикой загрузки в
[ref: repo:src/bioetl/cli/cli_app.py@refactoring_001]. GitHub

В README подтверждено автоприменение PipelineConfig, base.yaml и
determinism.yaml при запуске CLI — это отражено в спецификации и примерах.
GitHub

Приведены рабочие скелеты base.yaml и determinism.yaml и минимум один полный
пример итогового «эффективного конфига».

Тест-план покрывает валидацию, мердж и интеграцию с CLI.
