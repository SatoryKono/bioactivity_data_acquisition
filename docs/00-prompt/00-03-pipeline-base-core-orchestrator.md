> **Note**: Implementation status: **planned**. All file paths referencing `src/bioetl/` in this document describe the intended architecture and are not yet implemented in the codebase.

Промт: «Базовый оркестратор PipelineBase»
Роль и режим работы

Ты — системный аналитик ETL и разработчик. Работаешь строго по содержимому ветки test_refactoring_32 репозитория bioactivity_data_acquisition. Никаких внешних догадок. Источник истины — только файлы репозитория с явными ссылками формата:

[ref: repo:<path>@refactoring_001]

Источники (обязательные)

[ref: repo:src/bioetl/pipelines/base.py@refactoring_001] ← интерфейс/контракт базового оркестратора

[ref: repo:src/bioetl/cli/app.py@refactoring_001] ← интеграция с Typer/CLI, регистрация пайплайнов, входные точки
GitHub

[ref: repo:src/bioetl/configs/models.py@refactoring_001] ← модели конфигураций пайплайнов
GitHub

[ref: repo:docs/etl_contract/00-etl-overview.md@refactoring_001]

[ref: repo:docs/pipelines/00-pipeline-base.md@refactoring_001]

[ref: repo:README.md@refactoring_001] ← фиксация стадий extract → transform → validate → write, оркестрируемых методом run(), и принципов каркаса
GitHub

Задача

Подготовь спецификацию «Базовый оркестратор PipelineBase» на основе кода и текущей документации проекта. Спецификация должна быть самодостаточной: по ней можно реализовать новый пайплайн без чтения сторонних материалов.

Обязательное содержание спецификации

Назначение и границы

Что именно стандартизует PipelineBase и что выносит в реализацию конкретного источника (клиенты API, парсеры, нормализаторы, схемы). Зафиксируй универсальные стадии оркестрации extract → transform → validate → write, оркестрируемые методом run(), и их инварианты.
GitHub

Публичный API и типы

Точные сигнатуры абстрактных методов/протоколов:

class PipelineBase(Protocol):
    def extract(self) -> Iterable[dict]: ...
    def transform(self, rows: Iterable[dict]) -> Iterable[dict]: ...
    def validate(self, rows: Iterable[dict]) -> Iterable[dict]: ...
    def write(self, rows: Iterable[dict]) -> "WriteResult": ...
    def run(self) -> "RunResult": ...

Определи WriteResult и RunResult с полями: счетчики строк, путь вывода, meta и коды завершения.

Укажи требования к аннотациям типов и стабильности возвращаемых структур.

Жизненный цикл run()

Псевдокод вызовов: извлечение → трансформация → валидация → запись, включая измерение времени, логирование стадий, передачу контекста run_id/stage/source.

Требования к обработке исключений: где re-raise, где обогащение исключения контекстом, где возврат кода завершения.

Конфигурация и DI

Как пайплайн получает PipelineConfig и включает профили/слои (например, base.yaml + determinism.yaml), приоритет ключей, запрет на «немые» поля и поведение при неизвестных ключах.
GitHub

Логирование и телеметрия

Обязательные поля события лога для каждой стадии: run_id, stage, actor, source, level, duration_ms.

Формат JSON для файлов, текст/JSON для консоли; связь с CLI и единым логгером.

Политика редактирования секретов (маскирование токенов).

Корреляция с трассами при включенной телеметрии.

Детерминизм и артефакты вывода

Требования к стабильному порядку строк, сорт-ключам, хешам, фиксации meta.yaml (версии схем, row_count, контроль дубликатов).

Инварианты для повторного запуска с тем же конфигом.

Контракты валидации

Обязательные проверки Pandera/аналог: freeze колонок, типы, уникальность бизнес-ключа, внешние ключи при джойнах.

Политика эволюции схемы: версия, обратная совместимость, миграции.

Интеграция с CLI

Как пайплайн публикуется в Typer-команды, какие флаги обязательны (--config, --input-file, --output-dir, --dry-run), коды возврата и структура сообщений об ошибках. Пример вызова:

python -m bioetl.cli.app activity \
  --config configs/pipelines/activity/activity_chembl.yaml \
  --input-file data/input/activity.csv \
  --output-dir data/output/activity \
  --dry-run

Укажи место регистрации команд.
GitHub

Псевдокод оркестратора

Дай полный, исполнимо-реалистичный псевдокод PipelineBase.run() с try/finally, таймерами, логами, сбором метрик, генерацией WriteResult/RunResult, и точками расширения для ретраев/пагинации на extract().

Тест-план

Юнит-тесты для порядка стадий, обработки исключений, детерминизма и формата meta.yaml.

Golden-тест на стабильность вывода.

Интеграционный тест CLI: --dry-run обязан проходить без побочных эффектов и писать валидные логи.

Примеры

Один минимальный пример наследника PipelineBase с заглушками extract/transform/validate/write.

Таблица маппинга «стадия → точки расширения → инварианты».

Формат результата

Выдай один файл Markdown docs/pipelines/00-pipeline-base.md с разделами:

01. Обзор и цели

Публичный API (сигнатуры и типы)

Жизненный цикл и псевдокод run()

Конфигурация и DI

Логирование и телеметрия

Детерминизм и артефакты

Контракты валидации

Интеграция с CLI

Тест-план

Минимальный пример

Все ссылки на код и документацию внутри файла пиши строго как [ref: repo:<path>@refactoring_001].

Критерии приёмки (MUST)

Никаких ссылок вне репозитория.

Сигнатуры и стадии оркестрации соответствуют текущему коду и README (где зафиксирован каркас PipelineBase и CLI).
GitHub

В документе есть полный псевдокод run() и определены WriteResult/RunResult с полями.

Описана политика детерминизма, логирования и валидирующих инвариантов.

Пример наследника компилируем логически и покрывает все стадии.
