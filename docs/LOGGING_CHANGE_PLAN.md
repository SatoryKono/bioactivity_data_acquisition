> Deprecated: документ перенесён в архив и не является частью актуальной документации.

Актуальная версия доступна в `docs/archive/LOGGING_CHANGE_PLAN.md`.

## Шаг 1: Унификация и рефакторинг существующей системы

**Приоритет**: P1  
**Размер**: M (Medium)  
**Трудозатраты**: 4-6 часов

### Цель
Устранить дублирование конфигурации, создать единую точку управления логированием.

### Изменения в коде
- Создать `src/library/logging_setup.py` — унифицированный модуль конфигурации
- Удалить дублирующую логику из `logger.py` и `utils/logging.py`
- Мигрировать все импорты на новый модуль
- Сохранить маскирование секретов из `utils/logging.py`

### Критерии приёмки
- Один модуль конфигурации логирования
- Все тесты проходят
- Маскирование секретов работает
- Нет дублирования кода

### Затронутые файлы
- `src/library/logging_setup.py` (новый)
- `src/library/logger.py` (рефакторинг)
- `src/library/utils/logging.py` (рефакторинг)
- Все файлы, импортирующие `configure_logging`

---

## Шаг 2: Структурированное логирование с contextvars

**Приоритет**: P1  
**Размер**: M (Medium)  
**Трудозатраты**: 3-4 часа

### Цель
Добавить контекстные метаданные (run_id, stage) через contextvars для трассировки.

### Изменения в коде
- Внедрить `contextvars` для `run_id` (генерация UUID при старте pipeline)
- Добавить processor для автоматического включения `run_id` в `event_dict`
- Интегрировать `trace_id` из OpenTelemetry в контекст логов
- Создать функции `set_run_context()` и `get_run_context()`

### Критерии приёмки
- Логи содержат `run_id` и `stage`
- `trace_id` из telemetry включён в логи
- Вложенные контексты работают корректно
- Контекст сохраняется между вызовами

### Затронутые файлы
- `src/library/logging_setup.py`
- `src/library/etl/run.py`
- `src/library/cli/__init__.py`
- `src/library/telemetry.py`

---

## Шаг 3: Файловый handler с ротацией

**Приоритет**: P1  
**Размер**: L (Large)  
**Трудозатраты**: 4-5 часов

### Цель
Добавить `RotatingFileHandler` для записи логов на диск с автоматической ротацией.

### Изменения в коде
- Добавить `RotatingFileHandler` (maxBytes=10MB, backupCount=10)
- Создать директорию `logs/` при старте
- Расширить `LoggingSettings` в `config.py`:
  ```python
  class FileLoggingSettings(BaseModel):
      enabled: bool = Field(default=True)
      path: Path = Field(default=Path("logs/app.log"))
      max_bytes: int = Field(default=10485760)  # 10MB
      backup_count: int = Field(default=10)
  ```

### Критерии приёмки
- Логи пишутся в `logs/app.log`
- Ротация срабатывает при превышении размера
- Старые логи удаляются согласно `backupCount`
- Директория создаётся автоматически

### Затронутые файлы
- `src/library/logging_setup.py`
- `configs/config.yaml`
- `src/library/config.py`

---

## Шаг 4: Dual-format logging (консоль + файл)

**Приоритет**: P1  
**Размер**: M (Medium)  
**Трудозатраты**: 3-4 часа

### Цель
Разделить форматы для консоли (человекочитаемый текст) и файла (JSON).

### Изменения в коде
- `ConsoleHandler` с текстовым форматтером:
  ```
  %(asctime)s %(levelname)s %(name)s — %(message)s
  ```
- `FileHandler` с `JSONFormatter` для структурированных данных
- Конфигурация через `logging.console.format` и `logging.file.format`

### Критерии приёмки
- Консоль выводит читаемый текст с timestamp, level, message
- Файл содержит JSON с полными метаданными
- Оба handler используют маскирование секретов
- Форматы настраиваются через конфиг

### Затронутые файлы
- `src/library/logging_setup.py`
- `configs/config.yaml`

---

## Шаг 5: CLI флаги для управления логированием

**Приоритет**: P2  
**Размер**: S (Small)  
**Трудозатраты**: 2-3 часа

### Цель
Добавить флаги для переопределения конфигурации логов через CLI.

### Изменения в коде
- `--log-level {DEBUG|INFO|WARNING|ERROR|CRITICAL}`
- `--log-file PATH` — путь к файлу лога
- `--log-format {text|json}` — формат консольного вывода
- `--no-file-log` — отключить файловое логирование

### Критерии приёмки
- Флаги переопределяют `config.yaml`
- `--no-file-log` работает в dry-run режиме
- Флаги документированы в `--help`
- Валидация значений флагов

### Затронутые файлы
- `src/library/cli/__init__.py`
- `src/library/config.py`

---

## Шаг 6: TimedRotatingFileHandler с ретенцией

**Приоритет**: P2  
**Размер**: M (Medium)  
**Трудозатраты**: 3-4 часа

### Цель
Опциональная дневная ротация с автоочисткой старых логов.

### Изменения в коде
- Добавить `TimedRotatingFileHandler` (when='midnight', interval=1, backupCount=14)
- Конфигурация: `logging.file.rotation_strategy: {size|time}`
- Автоочистка логов старше `retention_days`

### Критерии приёмки
- Дневная ротация создаёт файлы `app.log.YYYY-MM-DD`
- Логи старше 14 дней удаляются
- Размерная ротация остаётся доступной
- Стратегия ротации настраивается

### Затронутые файлы
- `src/library/logging_setup.py`
- `configs/config.yaml`

---

## Шаг 7: Именование файлов с run_id

**Приоритет**: P3  
**Размер**: S (Small)  
**Трудозатраты**: 2-3 часа

### Цель
Уникальные имена файлов для каждого запуска pipeline.

### Изменения в коде
- Формат: `logs/{date}/run_{timestamp}_{run_id}.log`
- Создание директорий по дате
- Cleanup-скрипт для удаления старых директорий

### Критерии приёмки
- Каждый запуск создаёт уникальный файл
- Логи группируются по датам
- Старые директории очищаются
- Формат имени настраивается

### Затронутые файлы
- `src/library/logging_setup.py`
- `scripts/cleanup_logs.py` (новый)

---

## Шаг 8: Фильтр маскирования секретов

**Приоритет**: P1  
**Размер**: S (Small)  
**Трудозатраты**: 2-3 часа

### Цель
Централизованный фильтр для маскирования секретов в обоих handlers.

### Изменения в коде
- Класс `RedactSecretsFilter(logging.Filter)` с regex-заменой
- Паттерны: `token=\S+`, `api_key=\S+`, заголовки Authorization
- Применение к консольному и файловому handlers

### Критерии приёмки
- Секреты заменяются на `[REDACTED]` в обоих выводах
- Тесты проверяют маскирование ключей и токенов
- Производительность не деградирует
- Паттерны настраиваются

### Затронутые файлы
- `src/library/logging_setup.py`
- `tests/test_logging_security.py` (новый)

---

## Шаг 9: CI интеграция — архив логов

**Приоритет**: P2  
**Размер**: S (Small)  
**Трудозатраты**: 1-2 часа

### Цель
Сохранение логов как артефактов CI для отладки.

### Изменения в коде
```yaml
- name: Upload logs
  if: always()
  uses: actions/upload-artifact@v3
  with:
    name: test-logs-${{ matrix.python-version }}
    path: logs/
```
- Параметризация уровней: `BIOACTIVITY__LOGGING__LEVEL=DEBUG` в env CI

### Критерии приёмки
- Логи доступны в artifacts каждого CI запуска
- DEBUG level включён для детальной отладки
- Логи сохраняются даже при падении тестов (if: always())
- Артефакты именуются по версии Python

### Затронутые файлы
- `.github/workflows/ci.yaml`

---

## Шаг 10: Замена print() на логгеры

**Приоритет**: P2  
**Размер**: L (Large)  
**Трудозатраты**: 4-6 часов

### Цель
Устранить прямой вывод в stdout, заменить на структурированное логирование.

### Изменения в коде
- Заменить все `print()` в `src/library/tools/*.py` на `logger.info()`
- Pre-commit hook: `grep -r "print(" src/library/ && exit 1`
- Добавить импорты логгеров в tools

### Критерии приёмки
- Нет `print()` в `src/library` (кроме CLI-вывода `typer.echo`)
- Pre-commit хук блокирует коммиты с `print()`
- Все утилиты используют логгеры
- Маскирование секретов работает в tools

### Затронутые файлы
- `src/library/tools/*.py`
- `.pre-commit-config.yaml`

---

## Шаг 11: Документация

**Приоритет**: P2  
**Размер**: M (Medium)  
**Трудозатраты**: 2-3 часа

### Цель
Обновить документацию по логированию.

### Изменения в коде
- Раздел в README.md: флаги CLI, примеры конфигурации
- `docs/architecture.md`: архитектура логирования, форматы, ротация
- Примеры лог-строк JSON и текстовых

### Критерии приёмки
- Документация описывает все флаги и параметры
- Примеры для локального запуска и CI
- Политика ретенции задокументирована
- Примеры конфигурации работают

### Затронутые файлы
- `README.md`
- `docs/architecture.md`
- `docs/operations.md`

---

## Шаг 12: Maintenance-скрипт очистки логов

**Приоритет**: P3  
**Размер**: S (Small)  
**Трудозатраты**: 2-3 часа

### Цель
Автоматическая очистка старых логов.

### Изменения в коде
- Скрипт `scripts/cleanup_logs.py --older-than DAYS`
- Вызов при старте CLI (опционально): `logging.cleanup_on_start: true`
- Документация по ручному вызову

### Критерии приёмки
- Скрипт удаляет логи старше N дней
- Безопасное удаление (только в `logs/`)
- Опция автозапуска работает
- Логирование операций очистки

### Затронутые файлы
- `scripts/cleanup_logs.py` (новый)
- `src/library/logging_setup.py`

---

## Дорожная карта PR

### PR #1: Foundation (Шаги 1-4) — P1, критичен

**Зависимости**: Нет  
**Трудозатраты**: 14-19 часов  
**Ценность**: Базовое файловое логирование работает

**Включает**:
- Унификация конфигурации
- Contextvars для run_id/stage
- Файловый handler с ротацией
- Dual-format logging

### PR #2: Enhanced Features (Шаги 5-8) — P1-P2

**Зависимости**: PR #1  
**Трудозатраты**: 9-13 часов  
**Ценность**: Гибкая конфигурация, безопасность

**Включает**:
- CLI флаги
- TimedRotatingFileHandler
- Именование с run_id
- Фильтр маскирования

### PR #3: Operations & Cleanup (Шаги 9-12) — P2-P3

**Зависимости**: PR #2  
**Трудозатраты**: 9-14 часов  
**Ценность**: Операционная зрелость, удобство отладки

**Включает**:
- CI интеграция
- Замена print()
- Документация
- Cleanup-скрипт

## Итоговые трудозатраты

**Общая оценка**: 32-46 часов (4-6 рабочих дней)

## Критерии приёмки всего плана

1. ✅ Локальный запуск пишет консольный (text) и файловый (JSON) логи
2. ✅ Ротация (размер/время) работает, старые логи удаляются
3. ✅ Логи содержат run_id, stage, trace_id
4. ✅ Ошибки структурированы (exc_type, exc_message, stack)
5. ✅ В CI логи сохраняются как artifacts
6. ✅ Секреты маскируются во всех выводах
7. ✅ Нет print() в библиотечном коде
8. ✅ Документация полная и актуальная
