# Управление секретами для BioETL

Этот репозиторий больше не хранит реальные токены и ключи API. Файл
`.env.key.template` оставлен только как шаблон и не должен содержать рабочих
значений. Доступ к
секретам осуществляется через менеджер секретов (Vault) или через переменные
окружения, прокинутые в рантайм пайплайнов и CI.

## Стратегия хранения

### Prod / Staging

- **Vault** — источник правды для всех API-ключей (PubMed, Crossref, Semantic
  Scholar, IUPHAR и др.).
- **Названия секретов**: используйте единый префикс `bioetl/<environment>/` и
  храните ключи в формате JSON:
  ```json
  {
    "PUBMED_TOOL": "bioetl-document-pipeline",
    "PUBMED_EMAIL": "ml-team@example.org",
    "PUBMED_API_KEY": "...",
    "CROSSREF_MAILTO": "ml-team@example.org",
    "SEMANTIC_SCHOLAR_API_KEY": "...",
    "IUPHAR_API_KEY": "..."
  }
  ```
- **Доступ**: ограничьте ACL только сервисным аккаунтам пайплайна и членам
  команды данных.

### Локальная разработка

1. Скопируйте `.env.key.template` в `.env` (или `.env.key`, если инструмент
   его ожидает).
2. Выполните `vault kv get bioetl/dev/secrets > env.json` или получите значения
   иным способом от ответственного за секреты.
3. Распакуйте JSON в `.env` (например, `jq -r 'to_entries|map("\(.key)=\(.value)")|.[]' env.json > .env`).
4. Никогда не коммитьте `.env`, `.env.key` или другие файлы с реальными
   значениями.

### CI / Orchestration

- GitHub Actions/Argo должны читать секреты непосредственно из Vault или из
  настроенных переменных окружения (например, `SEMANTIC_SCHOLAR_API_KEY`), а не
  из файлов в репозитории.
- При необходимости используйте GitHub OIDC + Vault для динамического получения
  ключей во время выполнения.

## Ротация ключей

### Crossref `CROSSREF_MAILTO`

- Обратитесь к владельцу учётной записи Crossref и обновите контактный email.
- Обновите запись в Vault и подтвердите, что пайплайны используют новый email.

### Semantic Scholar `SEMANTIC_SCHOLAR_API_KEY`

- Сгенерируйте новый токен в личном кабинете Semantic Scholar.
- Аннулируйте старый токен, т.к. он был опубликован ранее.
- Обновите Vault и оповестите команду о необходимости перезапустить пайплайны.

Для остальных ключей пересмотрите статусы и ротацию в стандартном квартальном
цикле безопасности.

## Локальные артефакты и отчёты

Служебные скрипты и golden-тесты записывают результаты в каталог `artifacts/` в
корне репозитория. Директория автоматически создаётся по мере запуска скриптов и
исключена из Git (`.gitignore`), поэтому внутри можно свободно генерировать
отчёты без риска закоммитить артефакты.

Основные сценарии:

- `make dicts.aggregate` собирает словари ChEMBL в
  `artifacts/chembl_dictionaries.yaml`.
- `python audit_docs.py` формирует CSV/Markdown отчёты по документации (gaps,
  linkcheck и др.) внутри `artifacts/`.
- Скрипты из `scripts/` (`link_check.py`, `inventory_docs.py`,
  `semantic_diff.py`, `validate_config_schemas.py` и т.д.) и golden-тесты из
  `tests/` автоматически создают одноимённые отчёты в `artifacts/`.

Чтобы очистить рабочее окружение, достаточно удалить каталог `artifacts/` (он
будет заново создан при следующем запуске нужных скриптов).

## Обнаружение утечек секретов

### Автоматическая проверка

CI запускает `detect-secrets` по всем файлам репозитория. Проверка завершается с
ошибкой при обнаружении потенциального секрета. Ложноположительные срабатывания
фиксируйте через `.secrets.baseline` (не забудьте добавить поясняющий комментарий
в PR).

### Проверка перед коммитом

Рекомендуется добавить локальный pre-commit хук:

```bash
pip install detect-secrets
pre-commit install -t pre-commit
pre-commit install -t commit-msg
pre-commit run detect-secrets --all-files
```

## Реакция на инциденты

1. Немедленно отзовите скомпрометированный ключ в панели управления поставщика
   API.
2. Обновите секрет в Vault и проконтролируйте деплой конфигураций.
3. Создайте инцидент в системе тикетов и задокументируйте временную шкалу.
4. Добавьте регрессионный тест или правило в `detect-secrets`, чтобы предотвратить
   повторение проблемы.
