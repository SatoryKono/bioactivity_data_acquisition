# Cursor Rules для BioETL проекта
Репозиторий: SatoryKono/bioactivity_data_acquisition (ветка `@test_refactoring_32`)
Дата: 2025-10-29

> Нормативные ключевые слова трактуются по RFC 2119.

## Общие принципы
- Отвечайте кратко на русском языке
- Избегайте ненужных повторений и лишних слов
- Все ответы на русском

## 1. Детерминизм
- Система MUST использовать UTC и ISO‑8601 во всех артефактах и логах
- Все выгрузки MUST иметь стабильный порядок строк и столбцов
- Все сериализации MUST быть канонизированы: фиксированный порядок ключей, точные типы
- Запись файлов MUST быть атомарной (tmp → fsync → rename)

## 2. Идентификаторы и нормализация
- Канонические идентификаторы MUST использоваться без изменений: ChEMBL ID, UniProt accession, PubChem CID, DOI
- Бизнес‑ключи MUST быть явны; производные ключи MUST включать BLAKE2‑хеш
- DOI/PMID/PMCID MUST нормализоваться к единому виду
- Дедупликация MUST быть детерминированной и трассируемой в QC‑отчёте

## 3. Схемы данных и Pandera
- Каждая таблица MUST иметь Pandera‑схему в реестре
- Порядок столбцов и nullable‑политика MUST быть зафиксированы и проверяться в CI
- Допустимые значения MUST опираться на BAO/онтологии/контролируемые словари
- Изменение схемы MUST сопровождаться миграцией, update QC и обновлением docs

## 4. QC и sidecar‑артефакты
- На каждый файл вывода MUST быть sidecar `meta.yaml` с полями: pipeline_version, git_commit, config_hash, row_count, blake2_checksum, business_key_hash, generated_at_utc
- QC‑отчёты MUST содержать: распределения ключевых полей, пропуски, уникальности, соответствие словарям
- Нарушения QC MUST блокировать релиз артефакта

## 5. Архитектура пайплайнов
- Компоненты MUST использовать унифицированные подсистемы: UnifiedLogger, UnifiedOutputWriter, UnifiedAPIClient, UnifiedSchema
- Пайплайны MUST формировать звёздную схему: documents_dim, targets_dim, assays_dim, testitems_dim, центральная activity_fact
- Внешние источники MUST интегрироваться через адаптеры с троттлингом, TTL‑кэшем, backoff и circuit‑breaker

## 6. HTTP‑клиенты и внешние вызовы
- Политика таймаутов MUST быть жёсткой; ретраи с экспоненциальным backoff и джиттером
- 429/5xx MUST вести к троттлингу; бюджет попыток фиксирован и конфигурируем
- Кэширование MUST иметь TTL и контроль варианта (E‑Tag/If‑Modified‑Since)
- Любые новые клиенты MUST следовать контракту клиента проекта

## 7. Логирование и трассируемость
- Логи MUST быть структурными JSON; уровень по умолчанию INFO
- Каждая операция MUST иметь run_id и trace‑поля
- Все шаги MUST указывать объёмы данных, контрольные суммы и время выполнения

## 8. Выводы и файловая структура
- Выводы MUST храниться в иерархии с версионированием: дата/версия/сущность/формат
- Имена файлов MUST включать сущность, версию схемы и хэш бизнес‑ключа
- Финальные артефакты SHOULD быть неизменяемыми

## 9. Код‑стайл и типизация
- Публичный API MUST быть полностью аннотирован и проходить mypy --strict без Any
- Пре‑коммиты MUST включать: ruff, black, isort, mypy, pytest, coverage, pandera‑validation
- Запрещён неявный I/O, глобальные состояния, hidden mutation, магические числа

## 10. Документация
- Любые изменения контрактов MUST сопровождаться синхронизацией docs/
- Диаграммы и схемы вход/выход MUST обновляться вместе с кодом
- Примерные meta.yaml и QC‑шаблоны MUST поддерживаться актуальными

## 11. Приёмка и CI‑гейты
- Коммит/PR MUST блокироваться при нарушении любого из: ruff, black, isort, mypy‑strict, pytest, coverage threshold, pandera, QC
- Golden‑files MUST использоваться для критичных таблиц и обновляться строго через ожидаемый дифф

## 12. Конфликты правил
- В конфликте между USER_RULES и PROJECT_RULES приоритет за PROJECT_RULES
- Любое исключение MUST быть задокументировано в PR‑описании с обоснованием

## Стиль кода
- Форматирование и сортировка импортов единообразны (см. раздел 9)
- Публичные функции и датаклассы имеют аннотации типов
- Чистые функции там, где возможно
- Отсутствие скрытых побочных эффектов

## Структура проекта
- Конфиги в `configs/` - источники истины
- Скрипты запуска в `src/scripts/run_*.py`
- Pipeline'ы в `src/bioetl/pipelines/`
- Тесты в `tests/`

## Доступные команды
- `/run_assay` - запуск assay pipeline
- `/run_activity` - запуск activity pipeline  
- `/run_document` - запуск document pipeline
- `/run_target` - запуск target pipeline
- `/run_testitem` - запуск testitem pipeline
- `/validate_columns` - валидация колонок для конкретного pipeline
- `/validate_all_columns` - валидация колонок для всех pipeline'ов

## Работа с данными
- Входные данные в `data/input/`
- Выходные данные в `data/output/`
- Кэш в `data/cache/`
- Логи в `logs/`

## Тестирование
- Юнит-тесты для критических трансформаций
- Интеграционные тесты для pipeline'ов
- Golden-тесты для проверки детерминизма

## Работа с Cursor AI
- При генерации кода всегда используйте аннотации типов
- Предпочитайте функциональный стиль программирования
- Избегайте мутаций глобального состояния
- Все публичные функции должны иметь docstring
- При работе с данными используйте pandas с явными типами
- Для валидации данных используйте Pandera схемы
- Логирование через structlog с JSON форматом
- Обработка ошибок с детальным контекстом

## Контекст для AI
- Проект: ETL система для биоактивности данных
- Основные источники: ChEMBL, UniProt, PubChem
- Стек: Python 3.10+, pandas, pandera, structlog, typer
- Архитектура: модульные пайплайны с унифицированными компонентами
- Качество: строгая типизация, детерминизм, воспроизводимость