from __future__ import annotations

from typing import Any, Sequence

class BoundLogger:
    def bind(self, **kwargs: Any) -> BoundLogger: ...

    def unbind(self, *keys: str) -> BoundLogger: ...

    def new(self, **kwargs: Any) -> BoundLogger: ...

    def get(self, name: str | None = ...) -> BoundLogger: ...

    def info(self, event: str, /, **kwargs: Any) -> None: ...

    def warning(self, event: str, /, **kwargs: Any) -> None: ...

    def warn(self, event: str, /, **kwargs: Any) -> None: ...

    def error(self, event: str, /, **kwargs: Any) -> None: ...

    def exception(self, event: str, /, **kwargs: Any) -> None: ...

    def debug(self, event: str, /, **kwargs: Any) -> None: ...

    def critical(self, event: str, /, **kwargs: Any) -> None: ...

    def log(self, level: int, event: str, /, **kwargs: Any) -> None: ...

    def __call__(self, event: str, /, **kwargs: Any) -> None: ...


class ProcessorFormatter:
    @staticmethod
    def remove_processors_meta(logger: Any, name: str, event_dict: dict[str, Any]) -> dict[str, Any]: ...

    @staticmethod
    def wrap_for_formatter(logger: Any, name: str, event_dict: dict[str, Any]) -> dict[str, Any]: ...

    def __init__(
        self,
        *,
        processors: Sequence[Any],
        foreign_pre_chain: Sequence[Any] | None = ...,
    ) -> None: ...


class LoggerFactory:
    def __call__(self, *args: Any, **kwargs: Any) -> BoundLogger: ...


def add_log_level(logger: Any, name: str, event_dict: dict[str, Any]) -> dict[str, Any]: ...


def filter_by_level(logger: Any, name: str, event_dict: dict[str, Any]) -> dict[str, Any]: ...

